#! /bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
#
# `cpu-usage` monitor the CPU consumption of the threads of a process.
#
# Copyright (C) 2021 Christophe BLAESS <christophe.blaess@logilin.fr>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. 
#

Version=0.3

Refresh_delay=2
Process_PID=1

display_usage()
{
	echo "Usage: $0 [option] <pid>" >&2
	echo "Display the current CPU usage (user/kernel) of the threads of a process." >&2
	echo "Options: " >&2
	echo "  -h          This help" >&2
	echo "  -v          Display the version" >&2
	echo "  -n <delay>  Set the display refresh value in sec." >&2
}



display_version()
{
	echo "$0 v.${Version}" >&2
	echo "Copyright (c) 2021 Christophe BLAESS" >&2
	echo "License GPLv2: GNU GPL version 2 or later <https://gnu.org/licenses/gpl.html>." >&2
	echo "This is free software: you are free to change and redistribute it." >&2
	echo "There is NO WARRANTY, to the extent permitted by law." >&2
}




parse_args()
{
	OPTIND=0
	local opt
	while getopts ":hn:v" opt
	do
		case ${opt} in
			h)
				display_usage; exit 0
				;;
			n)
				Refresh_delay=$((${OPTARG}))
				;;
			v)
				display_version; exit 0
				;;
			:)
				echo "Missing argument for -$OPTARG option" >&2
				exit 1
				;;
			?)
				echo "Invalid option: -$OPTARG" >&2
				exit 1
				;;
		esac
	done

	shift $((OPTIND - 1))
	if [ $# -ne 1 ]
	then
		echo "$0: missing PID." >&2
		exit 1
	fi

	Proc_PID="${1}"
}



get_threads_list()
{
	if ! cd /proc/"${Proc_PID}"/task >/dev/null 2>&1
	then
		echo "$0: $1 is not a valid PID" >&2
		exit 1
	fi

	Threads_list=$( echo *)
}



get_cpu_count()
{
	CPU_count=$(cat /proc/stat | grep ^cpu[0-9]| wc -l)
}



get_current_system_ticks()
{
	local n=0

	while [ ${n} -lt ${CPU_count} ]
	do
		Current_system_tick[$n]=$(awk '(NR=='$((n + 2))'){print $2+$3+$4+$5}' < /proc/stat)
		n=$((n+1))
	done
}



compute_delta_system_ticks()
{
	local n=0

	while [ ${n} -lt ${CPU_count} ]
	do
		Delta_system_tick[$n]=$((${Current_system_tick[$n]} - ${Previous_system_tick[$n]}))
		n=$((n+1))
	done
}



store_current_system_ticks_as_previous()
{
	local n=0

	while [ ${n} -lt ${CPU_count} ]
	do
		Previous_system_tick[$n]=${Current_system_tick[$n]}
		n=$((n+1))
	done
}



get_current_tasks_values()
{
	local n=0
	local thr

	for thr in ${Threads_list}
	do
		if [ ! -d "/proc/"${Proc_PID}"/task/${thr}" ]; then exit 0; fi
		Task_cpu[$n]=$(awk '{print $39}' < /proc/"${Proc_PID}"/task/${thr}/stat)
		Current_user_time[$n]=$(awk '{print $14}' < /proc/"${Proc_PID}"/task/${thr}/stat)
		Current_kernel_time[$n]=$(awk '{print $15}' < /proc/"${Proc_PID}"/task/${thr}/stat)
		n=$((n+1))
	done
}



store_current_tasks_values_as_previous()
{
	local n=0
	local thr

	for thr in ${Threads_list}
	do
		Previous_user_time[$n]=${Current_user_time[$n]}
		Previous_kernel_time[$n]=${Current_kernel_time[$n]}
		n=$((n+1))
	done
}



compute_tasks_usages()
{
	local n=0
	local thr
	local user_delta
	local kernel_delta

	for thr in ${Threads_list}
	do
		user_delta=$((${Current_user_time[$n]} - ${Previous_user_time[$n]}))
		kernel_delta=$((${Current_kernel_time[$n]} - ${Previous_kernel_time[$n]}))
		User_task_percent[$n]=$((${user_delta} * 100 / ${Delta_system_tick[${Task_cpu[$n]}]}))
		Kernel_task_percent[$n]=$((${kernel_delta} * 100 / ${Delta_system_tick[${Task_cpu[$n]}]}))
		n=$((n+1))
	done
}



display_tasks_usages()
{
	local n=0
	local thr

	for thr in ${Threads_list}
	do
		printf "%d: %d/%d, " $thr ${User_task_percent[$n]} ${Kernel_task_percent[$n]}
		n=$((n + 1))
	done
	printf "\n"
}



main()
{
	parse_args $@

	get_threads_list

	get_cpu_count

	get_current_system_ticks
	get_current_tasks_values

	store_current_system_ticks_as_previous
	store_current_tasks_values_as_previous

	while true
	do
		sleep "${Refresh_delay}"

		get_current_system_ticks
		get_current_tasks_values

		compute_delta_system_ticks
		compute_tasks_usages

		store_current_system_ticks_as_previous
		store_current_tasks_values_as_previous

		display_tasks_usages
	done
}


main $@

